Sysadmins have to configure stuff
    We spend hours upon hours reading the friendly manuals, watching youtube videos, reading quickstarts and tutorials.
    A lot of what we owe our expertise to is the ability to google better than the next person.
    So we end up with the responsibility to maintain and configure infrastructure

Keeping track of things is hard
    which system is doing what
    what do we patch when
    which stuff in on prem and what's in the cloud
    How do I join my linux systems to our windows domain again?
    How do we keep track of all the things?

We document!
    Here's a list of effective methods of documenting.
    Shout out to my org mode folks?
    I have used them all, you may have your preferred method.
    But then we are still left with some problems.
    Documentation can drift as the system evolves over time.
    Where do we put all this documentation so it's accessible to the team?
    How do we make the time to document what we are changing?
    How do we keep track of changes to documentation and what that means to systems that are on the old way of doing things vs the new way?
    Personally, I hate documentation for the sake of documentation
    You can't document well if you don't know your audience
    Ideally the audience of my documentation is future me, and I don't know what future me is going to forget
    I know from present me that past me was an idiot and did things in very wonky ways
    So how can I keep all this documentation in a way that future me will thank past me and not think I'm an idiot

Infrastructure as code
    We can write our infrastructure as code and store everything in git
    Using git we can keep track of what changed when and by creating descriptive comments for ourselves
    Just by looking at the source code we can and answer, the who, what, where, how, why behind every infrastructure change
    And we aren't documenting for the sake of documentation.
    We are describing, in code, the actual system level changes that will modify our configuration

SaltStack
    Saltstack is a client server technology that, by default, runs as root/SYSTEM on the client
    you can use it to:
        run commands
        install software
        update software
        get information about systems
        store information about systems
        and declare all of this in code as "granular" as you like
    Get used to the salt puns, there are more to come
    Notice the minions are calling into the master
    One of the minions is in the "cloud"
    So what does a configuration change look like in saltstack

Xyz example
    SaltStack enables us to deploy configurations to servers and document the configuration
    What do we need, xyz installed
    How are we installing it, package manager or script
    We need to ensure it's installed or not, the "state" of the installation
    Where are we installing xyz
        Maybe specific servers A and C but not B
        Or all servers that have a specific attribute like an IP address of 10.200.something
    Then deploy our state
        This is where you would leave a helpful git comment for future you
        Git log will show us when, why, and who

Lab time!
    start up our three systems one master and two minions all three are debian/stretch
    install curl on all three and I'm going to install vim on the master since it's my editor of choice
    install the salt using the bootstrap script
    there's some magic happening in the background, the hostname "salt" resolves to the master
    I do not need to specify the salt master but there is a parameter to do that if you want to name salt
    something else or run salt over the internet.
    The minions will accept the master's key by default. If you recreate the master without the a backup of the master's
    key, the clients won't talk to the master anymore and you'll have to redeploy
    Now on the master we have to accept the minion's keys, there is mutual authentication occurring here but this exchange is
    susceptible to MITM so this should be done on a trusted network.
    And if you are running on the internet you don't want to just accept all clients. I plan on putting together some material
    on evil minions. We'll talk about that later.
    Now let's make sure everything works by pinging all minions.

Run commands
    Commands executed like this in saltstack happen in parallel
    All machines connected to the salt master will independently run the command and return in whatever order they finish
    And you'll be warned about minions that error
    At this point we have an extremely powerful tool. One console with a constant root shell to everything connected to it.
    You might be tempted to stop here and that would be perfectly understandable
    but let's see what else we can do

Grains
    Saltstack collects grains, bits of information about a host
    You can also set a grain for a host
    We can use grains to "target" systems

Targeting
    Without any switches, the default targeting uses shell style globbing
    It's customary to surround the target with single quotes so the command doesn't conflict with your shell
    We can also use lists, grains, subnets and many other methods for targeting
    You can combine as many as you like in a compound matcher with boolean logic that supports parenthesis

What is a state
    A state is two things in one, first a check to ensure the system has whatever you want it to have, second is
    whatever is required to take the system from it's current state to the state you want it to be in.
    Here we have two different state files that demonstrate the same thing.
    The first one is using saltstacks builtin abstration to the OSes package managager. On debian that's apt, if
    this was centos it would be yum.
    The second state file is more appropriate to use if the thing you want installed is not in the package manager.
    Since we are working on script and naming things it's a good idea at this point to start tracking changes.
    This is were git comes in.

Git
    This isn't a talk on how to use git. We are just going to use what we need and if we screw it up, that's ok
    we'll delete it all and just start over with a fresh copy.
    By default salt states are stored in the salt file server at /srv/salt. Let's initialize /srv/ and keep track
    of our new states.

Create a state file
    For our first state file we'll do something simple. We'll use the OSes builtin package manager
    to deploy screenfetch.
    Now we can test our state file be deploying it to one minion.
    It works, commit it!
    Ok we have a working state file, what do we do with it?

Now we can describe where this state gets deployed.

top.sls
    The top.sls file is a special significance. You can think of it like main. All minions will
    look to the top.sls file when applying state. In salt world they call this the highstate.
    I guess they ran out of puns. Or perhaps "seasoning" the systems was too much.
    Now we deploy call state.apply to set however many minions we want to set their highstate.
    Notice one of the minions failed hard. The reason there is that we called the state.apply
    and that minion doesn't have any states to apply.
    You should always be able to call state.apply to get your systems in the appropriate state
    without fear of causing significant disruption.

pillars
    Pillars are tree-like structures of data defined on the Salt Master and passed through to minions.
    They allow confidential, targeted data to be securely sent only to the relevant minion.
    Think of what happens if a minion went evil. If you had to distribute secrets, you wouldn't want all
    minions knowing all secrets. If you put your secrets in a state file, that's what you are doing. All
    minions have access to all data in the salt file server. Not so with pillar data.

/srv/pillar/users.sls

/srv/pillar/top.sls

